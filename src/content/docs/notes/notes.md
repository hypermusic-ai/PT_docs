---
title: Notes
description: loose thoughts
---

## Concepts

The basic representation of data on which PT operates are concepts.
Concept is **a defined sample type**, on with PT operates using **operators**.

In a *pseudo-OOP* definition we could understand concept as composition of types:

    namespace concepts {
     struct Pitch {
      float32 value
     }
     struct Duration {
      float32 value
     }
     struct Time{
      float32 value
     }
     ...
     struct Concept_A
     {
      Pitch pitch;
      Duration dur;
     }
     struct Concept_B
     {
      Time time
      Concept_A concept_A
     }
    }
*~ Concepts are not implemented like this,
this is for illustrative purposes only!*

At the very end every concept is defined either as a composition of other concepts, or as a scalar value of 32bit float representation.

Concepts are orthogonal relative to each other; in particular there are no comparison operators between two different concepts.

## Concepts compositions

As seen above concepts can be composed together to create new concepts.
In a definition provided above we defined custom concepts A and B which definition can be sumarized to:

`concept_A = [pitch, duration]`

`concept_B = [time, concept_A] = [time, [pitch, duration]]`

We assume that there should be no problem with using operators like `pitch + 1` just the same as `concept_B + 1`. To achive this transformation we'll use **operators**.

## Operators

Concepts can be modified using operators.
An operator is any function that takes a concept as an argument and returns the same type of concept as its value.

    function op0(concept_A: Concept_A, args...) : Concept_A
    {
     const [pitch, duration] = concept_A
     ...
     return [pitch + 2, duration *  3]
    }

Since concept could be composite types, its usefull to unwrap them inside operator, to perform modifications on separate sub-concepts.

    function op1(concept_B: Concept_B, args...) : Concept_B
    {
     const [time, concept_A]   = concept_B
     const [pitch, duration]   = concept_A
     ...
     return [time * 2, concept_A * 2]
    }
To model operator behavour additional arguments are provided to its input.

In the example above we **simplify  A LOT** - in particular we assumed that there are defined operators like:
`Pitch::operator + (int)`, `Duration::operator * (int)` `Time::operator * (int)` and `Concept_A::operator * (int)`.

**How could we define those basic mathematics operators?**

In particular how to define basic arthemtic operators for composed concepts?

We'll use assumption that only one PT generates given concept (`1:1`).  Yay!

> Since there is a need achive deterministic sequentiality, every concept is generated by **one, and only one** transaction, which means  `1:1` relation between concepts and PT generating it.

Specyfic PT, can generate space of sequential objects from specyfic concept - this entity  will be called **dimension** - this sequentiality gives us posibility to define basic addition and multiplication operators.

Since every object generated in a sequence has its uniquely determined index, there is no problem with defining transposition operators. In particular addition operator like `concept_B + 1` will be defined as the next object from **dimension** generated by PT assigned to `concept_B`. Which basically means, next index from a sequence.
There is also no problem with defining multiplication operator like `concept_B * 2` in this case we could silmply muiltiply object index to obtain other index from given **dimension** generated by PT.

To obtain full composability, even simple concepts, like `pitch` or `duration`, must be defined as generated by particular PT.

## Indexes

At this stage we can observe that we only operate on indexes - float32 values are not technically used at all.

Thats why above definition of concepts are only illustrative -
the actual implementation  focuses on transforming indexes from **dimension**, not to compute values behind those indexes.
This value retreival process - index to object mapping - will be performed when samples are requested from PT.

## Operators pattern

  PT statically defines list of operators for given concept - but apart from that there is a mechanism to modify this sequence of calls.
  This mechanism is called **operators pattern**.

Pattern function returns sequence of indexes to be performed from operators array.

 given operator definition:

      operators = [ op0, op1, op2, op3 ]

      idx(op0) => 0
      idx(op1) => 1
      idx(op2) => 2
      idx(op3) => 3

 we can use pattern like:

     function pattern_A() : [uint] {
      return [3, 0, 0]
     }

to obtain sequence of calls:
  
    operators[3] 
    operators[0]
    operators[0]
    operators[3]
    operators[0]
    operators[0]
    operators[3]
    ...
which results in final call of

     [op3, op0, op0, op3, ... ]

## PT definition

Up to this point we defined basic utilities from with PT can be constructed.
PT in its simplest form is just a metadata indicating used concepts, list of operators transforming it, and the operators' call pattern.

We can specify static PT definition:

    --- medatada
     IN   = [Time, Concept_A]
     OUT  = [Concept_B]
    --- transformations 
    [
    # sequential operator calls for Time concept
      [add(2), mul(3)],
    # sequential operator calls for Concept_A concept
      [op0]
    ]

And PT behavour modification arguments:

    --- patterns
    [
    # Operators pattern for Time concept
     pattern_A,
    # Operators pattern for Concept_A concept
     pattern_B
    ]

## Technicalities :/

Since we are resticted by constraints imposed on us by languages used to write smart contracts like `Solidity`, `SmartPy` or `Taquito`, we cannot simply define overloading for `+` or `*` operators.

There are many solutions to tackle this problem - for now the simplest one will be to define functions like `add` and `mul`
